# JobAutoLoaderConfig
job.autoloader.starting=Iniciando la carga automática y ejecución de jobs...
job.autoloader.noJobFilesFound=No se encontraron archivos job.yml en 'classpath*:jobs/**/job.yml'
job.autoloader.processingJobFile=Procesando job.yml encontrado en: {0}
job.autoloader.errorParsingJobFile=Error al leer o parsear job.yml desde {0}: {1}
job.autoloader.parametersLoaded=Parámetros cargados para el job ''{0}'' desde {1}
job.autoloader.errorParsingParametersFile=Error al leer o parsear parameters.yml para el job ''{0}'' en {1}: {2}. El job se ejecutará sin parámetros de archivo.
job.autoloader.parametersFileNotFound=No se encontró parameters.yml para el job ''{0}''. El job se ejecutará sin parámetros de archivo.
job.autoloader.errorAccessingParametersFile=Error al acceder a parameters.yml para el job ''{0}'': {1}
job.autoloader.missingRequiredParameter=El job ''{0}'' requiere el parámetro inicial ''{1}'', pero no fue encontrado. Esto podría causar errores.
job.autoloader.noDescription=Sin descripción proporcionada
job.autoloader.executingJob=Ejecutando job: {0} con ID: {1}
job.autoloader.jobCompletedSuccessfully=Job ''{0}'' completado exitosamente.
job.autoloader.errorDuringJobExecution=Error durante la ejecución del job ''{0}'': {1}
job.autoloader.jobSeparator=----------------------------------------------------
job.autoloader.baseDirNotFound=Directorio base de jobs no encontrado o ningún job.yml presente: {0}
job.autoloader.errorScanningJobDirs=Error al escanear los directorios de jobs: {0}
job.autoloader.finished=Carga automática y ejecución de jobs finalizada.

# Job ClassLoader
job.classloader.searchingPlugins=Buscando plugins en: {0}
job.classloader.addedToClasspath=Añadido al classpath del job: {0}
job.classloader.jarAddedToClasspath=Añadido JAR al classpath del job: {0}
job.classloader.errorAccessingLibDir=Error al acceder al directorio de librerías del job para {0}: {1}

# OrchestratorService
orchestrator.jobDefinitionNull=La JobDefinition proporcionada es nula. No se puede ejecutar el job.
orchestrator.executingJob=Ejecutando Job: {0} (ID: {1}) con ClassLoader: {2}
orchestrator.noDescription=Sin descripción
orchestrator.unnamedStage=Stage sin nombre
orchestrator.unnamedAction=acción sin nombre
orchestrator.executingStage=Ejecutando Stage: {0}
orchestrator.stageWithSubActions=Stage ''{0}'' tiene sub-acciones.
orchestrator.stageAsSingleAction=Stage ''{0}'' es una acción única de tipo: {1}
orchestrator.stageEmpty=Stage ''{0}'' no tiene subActions ni actionDefinition. Omitiendo.
orchestrator.executingAction=Ejecutando Action: {0} (Tipo: {1}) (Parte del Stage: ''{2}'')
orchestrator.actionResultSaved=Resultado de ''{0}'' guardado en contexto como: {1}
orchestrator.actionResultNull=Resultado de ''{0}'' fue nulo, no se guardó en: {1}
orchestrator.actionExecutionError=Error ejecutando Action ''{0}'' (Tipo: {1}) en Stage ''{2}'': {3}
orchestrator.jobCompleted=Job ''{0}'' completado. Contexto final: {1}

# SpelExpressionEvaluator
spel.evaluator.emptyExpression=Expresión SpEL vacía o nula, devolviendo null.
spel.evaluator.reservedKeyWarning=Una clave en el mapa de contexto (''{0}'') coincide con la variable reservada ''jobContext'' de SpEL. El valor original de #jobContext (el mapa completo) se mantendrá. Acceda a esta clave específica a través de #jobContext.{0} o renómbrela.
spel.evaluator.tclChanged=Cambiado ThreadContextClassLoader a: {0}
spel.evaluator.tclDefault=Usando ThreadContextClassLoader por defecto: {0}
spel.evaluator.evaluating=Evaluando SpEL: ''{0}'' con contexto raíz: {1}, jobContext anidado: {2}
spel.evaluator.evaluationError=Error evaluando expresión SpEL ''{0}'' con ClassLoader {1}: {2}
spel.evaluator.evaluationError.runtime=Error evaluando SpEL: {0}
spel.evaluator.nullToBooleanFalse=Expresión SpEL ''{0}'' evaluada a null, convirtiendo a Boolean.FALSE para tipo esperado Boolean.
spel.evaluator.nullForExpectedType=Expresión SpEL ''{0}'' evaluada a null, devolviendo null para tipo esperado {1}.
spel.evaluator.stringToNumberConversionError=Fallo en la conversión de String ''{0}'' a tipo numérico esperado {1}: {2}
spel.evaluator.stringToNumberConversionError.runtime=No se pudo convertir el String ''{0}'' al tipo numérico esperado {1}. {2}
spel.evaluator.typeConversionError=No se pudo convertir el resultado de la expresión ''{0}'' (tipo: {1}) al tipo esperado {2}
spel.evaluator.typeConversionError.runtime=No se pudo convertir el resultado de la expresión ''{0}'' (tipo: {1}) al tipo esperado {2}

# ActionExecutorFactory
factory.gettingExecutor=Obteniendo ejecutor para el tipo de acción: {0}
factory.unsupportedActionType=Tipo de acción no soportado: {0}
factory.unsupportedActionType.runtime=Tipo de acción no soportado: {0}

# SpelActionExecutor
executor.spel.executing=Ejecutando SpEL: {0}

# LoopActionExecutor
executor.loop.unnamed=Bucle sin nombre
executor.loop.starting=Iniciando {0}: {1}
executor.loop.invalidConfig=Error en {0}: Configuración de bucle inválida (ni ''collection'' ni ''from''/''to'' definidos).
executor.loop.collectionNotIterable=Error en {0}: La colección ''{1}'' no es iterable o es nula.
executor.loop.iteration.collection=Iteración de colección {0} para {1} = {2} (Índice: {3})
executor.loop.conditionError.collection=Error evaluando conditionExpression en bucle de colección: {0}. Deteniendo iteración.
executor.loop.conditionFalse.collection=Condición de bucle de colección evaluada a falso. Terminando bucle.
executor.loop.iteration.parentStage=Iteración de {0}
executor.loop.fromToError=Error en {0}: No se pudieron evaluar ''from'' o ''to'' como números. {1}
executor.loop.iteration.numeric=Iteración numérica {0} para {1} = {2}
executor.loop.conditionError.numeric=Error evaluando conditionExpression en bucle numérico: {0}. Deteniendo iteración.
executor.loop.conditionFalse.numeric=Condición de bucle numérico para {0} evaluada a falso (actual: {1}). Terminando bucle.
executor.loop.incrementError.notNumber=Error en {0}: IncrementExpression no evaluó a un número.
executor.loop.incrementError.evaluation=Error en {0}: Error evaluando IncrementExpression. {1}
executor.loop.infiniteLoopGuard=Bucle numérico para {0} parece estar en un bucle infinito. Terminando.

# ConditionalActionExecutor
executor.conditional.unnamed=Condicional sin nombre
executor.conditional.evaluating=Evaluando Condición para ''{0}'': {1}
executor.conditional.evaluationError=Error evaluando la condición ''{0}''. Se considerará como falso. {1}
executor.conditional.true=Condición ''{0}'' verdadera. Ejecutando thenActions.
executor.conditional.thenBranch={0} (Rama Then)
executor.conditional.false=Condición ''{0}'' falsa. Omitiendo thenActions.

# CommandActionExecutor
executor.command.executing=Ejecutando Comando ''{0}'': {1}
executor.command.argEvaluationError=No se pudo evaluar el argumento SpEL ''{0}''. Usando literal. Error: {1}
executor.command.fullCommand=Comando completo a ejecutar: {0}
executor.command.outputLine=[Salida CMD] {0}
executor.command.finished=Comando ''{0}'' finalizado con código de salida: {1}
executor.command.nonZeroExit=Comando ''{0}'' devolvió un código de salida no cero: {1}
executor.command.executionError=Error ejecutando comando ''{0}'': {1}
executor.command.executionError.runtime=Error ejecutando comando {0}

# JavaMethodActionExecutor
executor.javamethod.executing=Ejecutando Método Java: {0}
executor.javamethod.beanNotFound=Error: Bean ''{0}'' no encontrado en el contexto de Spring.
executor.javamethod.beanNotFound.runtime=Bean no encontrado: {0}
executor.javamethod.argEvaluated=Arg {0} evaluado: {1}
executor.javamethod.methodNotFound=Error: Método ''{0}'' no encontrado en bean ''{1}'' con los parámetros adecuados.
executor.javamethod.methodNotFound.runtime=Método {0} no encontrado
executor.javamethod.methodNotFound.exception=Error: Método no encontrado - {0}
executor.javamethod.methodNotFound.exception.runtime=Método no encontrado: {0}
executor.javamethod.executionError=Error inesperado al ejecutar método Java ''{0}'': {1}
executor.javamethod.executionError.runtime=Error ejecutando método Java: {0}

# ... (mensajes existentes) ...
orchestrator.executingActionWithLineage=Ejecutando Action: {0} (Tipo: {1}) (Contexto: {2})
orchestrator.actionExecutionErrorWithLineage=Error ejecutando Action ''{0}'' (Tipo: {1}) en Contexto ''{2}'': {3}
executor.loop.startingWithinContext=Iniciando {0}: {1} (Contexto: {2})
executor.loop.iteration.collectionWithLineage=Iteración de colección ({0}) para {1} = {2} (Índice: {3})
executor.loop.conditionFalse.numericWithLineage=Condición de bucle numérico ({0}) para {1} evaluada a falso (actual: {2}). Terminando bucle.
executor.loop.iteration.numericWithLineage=Iteración numérica ({0}) para {1} = {2}
executor.conditional.evaluatingWithLineage=Evaluando Condición para ''{0}'': {1} (Contexto: {2})