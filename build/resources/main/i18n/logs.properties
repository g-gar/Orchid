# JobAutoLoaderConfig
job.autoloader.starting=Starting automatic job loading and execution...
job.autoloader.noJobFilesFound=No job.yml files found in 'classpath*:jobs/**/job.yml'
job.autoloader.processingJobFile=Processing job.yml found at: {0}
job.autoloader.errorParsingJobFile=Error reading or parsing job.yml from {0}: {1}
job.autoloader.parametersLoaded=Parameters loaded for job ''{0}'' from {1}
job.autoloader.errorParsingParametersFile=Error reading or parsing parameters.yml for job ''{0}'' at {1}: {2}. Job will run without file parameters.
job.autoloader.parametersFileNotFound=parameters.yml not found for job ''{0}''. Job will run without file parameters.
job.autoloader.errorAccessingParametersFile=Error accessing parameters.yml for job ''{0}'': {1}
job.autoloader.missingRequiredParameter=Job ''{0}'' requires initial parameter ''{1}'', but it was not found. This might cause errors.
job.autoloader.noDescription=No description provided
job.autoloader.executingJob=Executing job: {0} with ID: {1}
job.autoloader.jobCompletedSuccessfully=Job ''{0}'' completed successfully.
job.autoloader.errorDuringJobExecution=Error during execution of job ''{0}'': {1}
job.autoloader.jobSeparator=----------------------------------------------------
job.autoloader.baseDirNotFound=Job base directory not found or no job.yml present: {0}
job.autoloader.errorScanningJobDirs=Error scanning job directories: {0}
job.autoloader.finished=Automatic job loading and execution finished.

# Job ClassLoader
job.classloader.searchingPlugins=Searching for plugins in: {0}
job.classloader.addedToClasspath=Added to job classpath: {0}
job.classloader.jarAddedToClasspath=Added JAR to job classpath: {0}
job.classloader.errorAccessingLibDir=Error accessing job library directory for {0}: {1}

# OrchestratorService
orchestrator.jobDefinitionNull=Provided JobDefinition is null. Cannot execute job.
orchestrator.executingJob=Executing Job: {0} (ID: {1}) with ClassLoader: {2}
orchestrator.noDescription=No description
orchestrator.unnamedStage=Unnamed Stage
orchestrator.unnamedAction=unnamed action
orchestrator.executingStage=Executing Stage: {0}
orchestrator.stageWithSubActions=Stage ''{0}'' has sub-actions.
orchestrator.stageAsSingleAction=Stage ''{0}'' is a single action of type: {1}
orchestrator.stageEmpty=Stage ''{0}'' has no subActions or actionDefinition. Skipping.
orchestrator.executingAction=Executing Action: {0} (Type: {1}) (Part of Stage: ''{2}'')
orchestrator.actionResultSaved=Result of ''{0}'' saved to context as: {1}
orchestrator.actionResultNull=Result of ''{0}'' was null, not saved to: {1}
orchestrator.actionExecutionError=Error executing Action ''{0}'' (Type: {1}) in Stage ''{2}'': {3}
orchestrator.jobCompleted=Job ''{0}'' completed. Final context: {1}

# SpelExpressionEvaluator
spel.evaluator.emptyExpression=Empty or null SpEL expression, returning null.
spel.evaluator.reservedKeyWarning=A key in the context map (''{0}'') matches the reserved SpEL variable ''jobContext''. The original #jobContext (the full map) will be maintained. Access this specific key via #jobContext.{0} or rename it.
spel.evaluator.tclChanged=Changed ThreadContextClassLoader to: {0}
spel.evaluator.tclDefault=Using default ThreadContextClassLoader: {0}
spel.evaluator.evaluating=Evaluating SpEL: ''{0}'' with root context: {1}, nested jobContext: {2}
spel.evaluator.evaluationError=Error evaluating SpEL expression ''{0}'' with ClassLoader {1}: {2}
spel.evaluator.evaluationError.runtime=Error evaluating SpEL: {0}
spel.evaluator.nullToBooleanFalse=SpEL expression ''{0}'' evaluated to null, converting to Boolean.FALSE for expected type Boolean.
spel.evaluator.nullForExpectedType=SpEL expression ''{0}'' evaluated to null, returning null for expected type {1}.
spel.evaluator.stringToNumberConversionError=Failed to convert String ''{0}'' to expected numeric type {1}: {2}
spel.evaluator.stringToNumberConversionError.runtime=Could not convert String ''{0}'' to expected numeric type {1}. {2}
spel.evaluator.typeConversionError=Could not convert result of expression ''{0}'' (type: {1}) to expected type {2}
spel.evaluator.typeConversionError.runtime=Could not convert result of expression ''{0}'' (type: {1}) to expected type {2}

# ActionExecutorFactory
factory.gettingExecutor=Getting executor for action type: {0}
factory.unsupportedActionType=Unsupported action type: {0}
factory.unsupportedActionType.runtime=Unsupported action type: {0}

# SpelActionExecutor
executor.spel.executing=Executing SpEL: {0}

# LoopActionExecutor
executor.loop.unnamed=Unnamed Loop
executor.loop.starting=Starting {0}: {1}
executor.loop.invalidConfig=Error in {0}: Invalid loop configuration (neither ''collection'' nor ''from''/''to'' defined).
executor.loop.collectionNotIterable=Error in {0}: Collection ''{1}'' is not iterable or is null.
executor.loop.iteration.collection=Collection Iteration {0} for {1} = {2} (Index: {3})
executor.loop.conditionError.collection=Error evaluating conditionExpression in collection loop: {0}. Stopping iteration.
executor.loop.conditionFalse.collection=Collection loop condition evaluated to false. Terminating loop.
executor.loop.iteration.parentStage={0} Iteration
executor.loop.fromToError=Error in {0}: Could not evaluate ''from'' or ''to'' as numbers. {1}
executor.loop.iteration.numeric=Numeric Iteration {0} for {1} = {2}
executor.loop.conditionError.numeric=Error evaluating conditionExpression in numeric loop: {0}. Stopping iteration.
executor.loop.conditionFalse.numeric=Numeric loop condition for {0} evaluated to false (current: {1}). Terminating loop.
executor.loop.incrementError.notNumber=Error in {0}: IncrementExpression did not evaluate to a number.
executor.loop.incrementError.evaluation=Error in {0}: Error evaluating IncrementExpression. {1}
executor.loop.infiniteLoopGuard=Numeric loop for {0} appears to be in an infinite loop. Terminating.

# ConditionalActionExecutor
executor.conditional.unnamed=Unnamed Conditional
executor.conditional.evaluating=Evaluating Condition for ''{0}'': {1}
executor.conditional.evaluationError=Error evaluating condition ''{0}''. Will be treated as false. {1}
executor.conditional.true=Condition ''{0}'' true. Executing thenActions.
executor.conditional.thenBranch={0} (Then)
executor.conditional.false=Condition ''{0}'' false. Skipping thenActions.

# CommandActionExecutor
executor.command.executing=Executing Command ''{0}'': {1}
executor.command.argEvaluationError=Could not evaluate SpEL argument ''{0}''. Using literal. Error: {1}
executor.command.fullCommand=Full command to execute: {0}
executor.command.outputLine=[CMD Output] {0}
executor.command.finished=Command ''{0}'' finished with exit code: {1}
executor.command.nonZeroExit=Command ''{0}'' returned non-zero exit code: {1}
executor.command.executionError=Error executing command ''{0}'': {1}
executor.command.executionError.runtime=Error executing command {0}

# JavaMethodActionExecutor
executor.javamethod.executing=Executing Java Method: {0}
executor.javamethod.beanNotFound=Error: Bean ''{0}'' not found in Spring context.
executor.javamethod.beanNotFound.runtime=Bean not found: {0}
executor.javamethod.argEvaluated=Arg {0} evaluated: {1}
executor.javamethod.methodNotFound=Error: Method ''{0}'' not found in bean ''{1}'' with suitable parameters.
executor.javamethod.methodNotFound.runtime=Method {0} not found
executor.javamethod.methodNotFound.exception=Error: Method not found - {0}
executor.javamethod.methodNotFound.exception.runtime=Method not found: {0}
executor.javamethod.executionError=Unexpected error while executing Java method ''{0}'': {1}
executor.javamethod.executionError.runtime=Error executing Java method: {0}

orchestrator.executingActionWithLineage=Executing Action: {0} (Type: {1}) (Context: {2})
orchestrator.actionExecutionErrorWithLineage=Error executing Action ''{0}'' (Type: {1}) in Context ''{2}'': {3}
executor.loop.startingWithinContext=Starting {0}: {1} (Context: {2})
executor.loop.iteration.collectionWithLineage=Collection Iteration ({0}) for {1} = {2} (Index: {3})
executor.loop.conditionFalse.numericWithLineage=Numeric loop condition ({0}) for {1} evaluated to false (current: {2}). Terminating loop.
executor.loop.iteration.numericWithLineage=Numeric Iteration ({0}) for {1} = {2}
executor.conditional.evaluatingWithLineage=Evaluating Condition for ''{0}'': {1} (Context: {2})