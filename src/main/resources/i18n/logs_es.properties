# JobAutoLoaderConfig
job.autoloader.starting=Iniciando la carga automática y ejecución de jobs...
job.autoloader.noJobFilesFound=No se encontraron archivos job.yml en 'classpath*:jobs/**/job.yml'
job.autoloader.processingJobFile=Procesando job.yml encontrado en: {0}
job.autoloader.errorParsingJobFile=Error al leer o parsear job.yml desde {0}: {1}
job.autoloader.parametersLoaded=Parámetros cargados para el job ''{0}'' desde {1}
job.autoloader.errorParsingParametersFile=Error al leer o parsear parameters.yml para el job ''{0}'' en {1}: {2}. El job se ejecutará sin parámetros de archivo.
job.autoloader.parametersFileNotFound=No se encontró parameters.yml para el job ''{0}''. El job se ejecutará sin parámetros de archivo.
job.autoloader.errorAccessingParametersFile=Error al acceder a parameters.yml para el job ''{0}'': {1}
job.autoloader.missingRequiredParameter=El job ''{0}'' requiere el parámetro inicial ''{1}'', pero no fue encontrado. Esto podría causar errores.
job.autoloader.noDescription=Sin descripción proporcionada
job.autoloader.executingJob=Ejecutando job: {0} con ID: {1}
job.autoloader.executingJobWithLoader=Ejecutando job: {0} con ID: {1} usando ClassLoader: {2}
job.autoloader.parametersFlattened=Parámetros iniciales aplanados para el job ''{0}'': {1}
job.autoloader.jobCompletedSuccessfully=Job ''{0}'' completado exitosamente.
job.autoloader.errorDuringJobExecution=Error durante la ejecución del job ''{0}'': {1}
job.autoloader.jobSeparator=----------------------------------------------------
job.autoloader.baseDirNotFound=Directorio base de jobs no encontrado o ningún job.yml presente: {0}
job.autoloader.errorScanningJobDirs=Error al escanear los directorios de jobs: {0}
job.autoloader.finished=Carga automática y ejecución de jobs finalizada.
job.autoloader.cannotGetJobResourcePath=No se pudo obtener la ruta URL para el recurso del job: {0}

# Job ClassLoader
job.classloader.creatingForJob=Creando ClassLoader para el job ''{0}'' (recurso: {1})
job.classloader.cannotGetFileForResource=No se puede obtener el archivo para el recurso (podría estar dentro de un JAR o no ser un recurso del sistema de archivos): {0}. Error: {1}
job.classloader.libDiscoveryInJarLimited=La detección de la librería 'lib/' para el recurso del job {0} (que está dentro de un JAR) es limitada. Los plugins deberían estar en el classpath principal o empaquetados con el job.
job.classloader.unsupportedResourceProtocol=Protocolo de recurso no soportado ''{0}'' para el recurso del job: {1}
job.classloader.searchingPlugins=Buscando plugins en: {0}
job.classloader.searchingPluginsInDir=Buscando plugins para el job ''{0}'' en el directorio: {1}
job.classloader.addedToClasspath=Añadido al classpath del job: {0}
job.classloader.addedDirToClasspath=Directorio añadido al classpath del job ''{0}'': {1}
job.classloader.jarAddedToClasspath=JAR añadido al classpath del job ''{0}'': {1}
job.classloader.libDirNotFound=Directorio 'lib/' no encontrado en: {0}
job.classloader.libDirNotFoundForJob=Directorio 'lib/' no encontrado para el job ''{0}'' en la ruta esperada: {1}
job.classloader.cannotGetParentDir=No se pudo obtener el directorio padre para el archivo del job: {0}
job.classloader.jobFileNotAccessible=El archivo del job para el recurso {0} no es accesible o no existe en el sistema de archivos.
job.classloader.errorAccessingLibDir=Error al acceder al directorio de librerías del job para job ''{0}'' (recurso: {1}): {2}
job.classloader.parentClassLoader=ClassLoader padre para el job ''{0}'': {1}
job.classloader.creatingUrlClassLoader=Creando URLClassLoader para el job ''{0}'' con URLs: {1}
job.classloader.createdSuccessfully=URLClassLoader creado exitosamente para el job ''{0}'': {1}. URLs: {2}
job.classloader.noPluginsFound=No se encontraron plugins (JARs o directorio 'lib/') para el job ''{0}''. Usando ClassLoader padre: {1}

# OrchestratorService
orchestrator.jobDefinitionNull=La JobDefinition proporcionada es nula. No se puede ejecutar el job.
orchestrator.executingJob=Ejecutando Job: {0} (ID: {1}) con ClassLoader: {2}
orchestrator.noDescription=Sin descripción
orchestrator.unnamedStage=Stage sin nombre
orchestrator.unnamedAction=acción sin nombre
orchestrator.executingStage=Ejecutando Stage: {0}
orchestrator.stageWithSubActions=Stage ''{0}'' tiene sub-acciones.
orchestrator.stageAsSingleAction=Stage ''{0}'' es una acción única de tipo: {1}
orchestrator.stageEmpty=Stage ''{0}'' no tiene subActions ni actionDefinition. Omitiendo.
orchestrator.executingAction=Ejecutando Action: {0} (Tipo: {1}) (Parte del Stage: ''{2}'')
orchestrator.executingActionWithLineage=Ejecutando Action: {0} (Tipo: {1}) (Contexto: {2})
orchestrator.actionResultSaved=Resultado de ''{0}'' guardado en contexto como: {1}
orchestrator.actionResultNull=Resultado de ''{0}'' fue nulo, no se guardó en: {1}
orchestrator.actionResultNullOrNotSaved=El resultado de ''{0}'' fue nulo o no se guardó en la clave de contexto: {1}
orchestrator.actionExecutionError=Error ejecutando Action ''{0}'' (Tipo: {1}) en Stage ''{2}'': {3}
orchestrator.actionExecutionErrorWithLineage=Error ejecutando Action ''{0}'' (Tipo: {1}) en Contexto ''{2}'': {3}
orchestrator.jobCompleted=Job ''{0}'' completado. Contexto final: {1}
orchestrator.unboxedOptionalResult=Acción ''{0}'': Resultado Optional desenrollado a: {1}
orchestrator.evaluatingReturnToContextAsSpel=Acción ''{0}'': Evaluando SpEL de returnToContextAs: {1}
orchestrator.returnToContextAsSpelEvaluated=Acción ''{0}'': SpEL en returnToContextAs evaluada: {1}

# SpelExpressionEvaluator
spel.evaluator.emptyExpression=Expresión SpEL vacía o nula, devolviendo null.
spel.evaluator.reservedKeyWarning=Una clave en el mapa de contexto (''{0}'') coincide con la variable reservada ''jobContext'' de SpEL. El valor original de #jobContext (el mapa completo) se mantendrá. Acceda a esta clave específica a través de #jobContext.{0} o renómbrela.
spel.evaluator.tclChanged=Cambiado ThreadContextClassLoader a: {0}
spel.evaluator.tclDefault=Usando ThreadContextClassLoader por defecto: {0}
spel.evaluator.evaluating=Evaluando SpEL: ''{0}'' con contexto raíz: {1}, jobContext anidado: {2}
spel.evaluator.evaluationError=Error evaluando expresión SpEL ''{0}'' con ClassLoader {1}: {2}
spel.evaluator.evaluationError.runtime=Error evaluando SpEL: {0}
spel.evaluator.nullToBooleanFalse=Expresión SpEL ''{0}'' evaluada a null, convirtiendo a Boolean.FALSE para tipo esperado Boolean.
spel.evaluator.nullForExpectedType=Expresión SpEL ''{0}'' evaluada a null, devolviendo null para tipo esperado {1}.
spel.evaluator.stringToNumberConversionError=Fallo en la conversión de String ''{0}'' a tipo numérico esperado {1}: {2}
spel.evaluator.stringToNumberConversionError.runtime=No se pudo convertir el String ''{0}'' al tipo numérico esperado {1}. {2}
spel.evaluator.typeConversionError=No se pudo convertir el resultado de la expresión ''{0}'' (tipo: {1}) al tipo esperado {2}
spel.evaluator.typeConversionError.runtime=No se pudo convertir el resultado de la expresión ''{0}'' (tipo: {1}) al tipo esperado {2}

# ActionExecutorFactory
factory.gettingExecutor=Obteniendo ejecutor para el tipo de acción: {0}
factory.unsupportedActionType=Tipo de acción no soportado: {0}
factory.unsupportedActionType.runtime=Tipo de acción no soportado: {0}

# SpelActionExecutor
executor.spel.executing=Ejecutando SpEL: {0}

# LoopActionExecutor
executor.loop.unnamed=Bucle sin nombre
executor.loop.starting=Iniciando {0}: {1}
executor.loop.startingWithinContext=Iniciando {0}: {1} (Contexto: {2})
executor.loop.invalidConfig=Error en {0}: Configuración de bucle inválida (ni ''collection'' ni ''from''/''to'' definidos).
executor.loop.collectionNotIterable=Error en {0}: La colección ''{1}'' no es iterable o es nula.
executor.loop.iteration.collection=Iteración de colección {0} para {1} = {2} (Índice: {3})
executor.loop.iteration.collectionWithLineage=Iteración de colección ({0}) para {1} = {2} (Índice: {3})
executor.loop.conditionError.collection=Error evaluando conditionExpression en bucle de colección: {0}. Deteniendo iteración.
executor.loop.conditionFalse.collection=Condición de bucle de colección evaluada a falso. Terminando bucle.
executor.loop.iteration.parentStage=Iteración de {0}
executor.loop.fromToError=Error en {0}: No se pudieron evaluar ''from'' o ''to'' como números. {1}
executor.loop.iteration.numeric=Iteración numérica {0} para {1} = {2}
executor.loop.iteration.numericWithLineage=Iteración numérica ({0}) para {1} = {2}
executor.loop.conditionError.numeric=Error evaluando conditionExpression en bucle numérico: {0}. Deteniendo iteración.
executor.loop.conditionFalse.numeric=Condición de bucle numérico para {0} evaluada a falso (actual: {1}). Terminando bucle.
executor.loop.conditionFalse.numericWithLineage=Condición de bucle numérico ({0}) para {1} evaluada a falso (actual: {2}). Terminando bucle.
executor.loop.incrementError.notNumber=Error en {0}: IncrementExpression no evaluó a un número.
executor.loop.incrementError.evaluation=Error en {0}: Error evaluando IncrementExpression. {1}
executor.loop.infiniteLoopGuard=Bucle numérico para {0} parece estar en un bucle infinito. Terminando.

# ConditionalActionExecutor
executor.conditional.unnamed=Condicional sin nombre
executor.conditional.evaluating=Evaluando Condición para ''{0}'': {1}
executor.conditional.evaluatingWithLineage=Evaluando Condición para ''{0}'': {1} (Contexto: {2})
executor.conditional.evaluationError=Error evaluando la condición ''{0}''. Se considerará como falso. {1}
executor.conditional.true=Condición ''{0}'' verdadera. Ejecutando thenActions.
executor.conditional.thenBranch={0} (Rama Then)
executor.conditional.false=Condición ''{0}'' falsa. Omitiendo thenActions.

# CommandActionExecutor
executor.command.executing=Ejecutando Comando ''{0}'': {1}
executor.command.argEvaluationError=No se pudo evaluar el argumento SpEL ''{0}''. Usando literal. Error: {1}
executor.command.fullCommand=Comando completo a ejecutar: {0}
executor.command.outputLine=[Salida CMD] {0}
executor.command.finished=Comando ''{0}'' finalizado con código de salida: {1}
executor.command.nonZeroExit=Comando ''{0}'' devolvió un código de salida no cero: {1}
executor.command.executionError=Error ejecutando comando ''{0}'': {1}
executor.command.executionError.runtime=Error ejecutando comando {0}

# JavaMethodActionExecutor
executor.javamethod.executing=Ejecutando Método Java: {0}
executor.javamethod.resolvedFromContext=Destino ''{0}'' resuelto desde jobContext como instancia de {1}.
executor.javamethod.contextKeyNull=Destino ''{0}'' encontrado en jobContext, pero su valor es nulo. Se intentará como bean de Spring o FQCN.
executor.javamethod.resolvedAsBean=Destino ''{0}'' resuelto como un bean de Spring.
executor.javamethod.notABeanOrContextKey=Destino ''{0}'' no encontrado como bean de Spring ni en jobContext. Intentando cargar como clase.
executor.javamethod.loadingClass=Intentando cargar clase ''{0}'' usando ClassLoader específico del job: {1}
executor.javamethod.classLoaded=Clase ''{0}'' cargada exitosamente.
executor.javamethod.classInstantiated=Clase ''{0}'' instanciada exitosamente usando constructor sin argumentos.
executor.javamethod.classNotFoundInJobClassLoader=Clase ''{0}'' no encontrada en ClassLoader específico del job {1}.
executor.javamethod.classNotFoundInJobClassLoader.runtime=Clase no encontrada en ClassLoader del job: {0}
executor.javamethod.noArgConstructorNotFound=Constructor sin argumentos no encontrado para la clase ''{0}''.
executor.javamethod.noArgConstructorNotFound.runtime=Constructor sin argumentos no encontrado para la clase: {0}
executor.javamethod.classInstantiationError=Error instanciando la clase ''{0}'': {1}
executor.javamethod.classInstantiationError.runtime=Error instanciando la clase: {0}
executor.javamethod.notBeanAndNoJobClassLoader=El destino ''{0}'' no es un bean de Spring y no hay un ClassLoader específico del job disponible para cargarlo como clase.
executor.javamethod.notBeanAndNoJobClassLoader.runtime=Destino no encontrado como bean y sin ClassLoader de job disponible para cargar como clase: {0}
executor.javamethod.beanResolutionError=Error resolviendo el destino ''{0}'': {1}
executor.javamethod.beanResolutionError.runtime=Error resolviendo el destino: {0}
executor.javamethod.targetInstanceNull=La instancia de destino para ''{0}'' es nula después de intentar la resolución.
executor.javamethod.targetInstanceNull.runtime=La instancia de destino es nula para: {0}
executor.javamethod.methodNotFound=Error: Método ''{0}'' no encontrado en bean ''{1}'' con los parámetros adecuados.
executor.javamethod.methodNotFoundDetailed=Error: Método ''{0}'' con tipos de argumento {1} no encontrado en el destino ''{2}''.
executor.javamethod.methodNotFound.runtime=Método {0} no encontrado
executor.javamethod.methodNotFound.exception=Error: Método no encontrado - {0}
executor.javamethod.methodNotFound.exception.runtime=Método no encontrado: {0}
executor.javamethod.executionError=Error inesperado al ejecutar método Java ''{0}'': {1}
executor.javamethod.executionError.runtime=Error ejecutando método Java: {0}
executor.javamethod.targetNotFound=El destino ''{0}'' no pudo ser resuelto (no está en jobContext, no es un bean de Spring, y no se puede cargar como clase).
executor.javamethod.targetNotFound.runtime=El destino no pudo ser resuelto: {0}
